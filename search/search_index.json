{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Wiggly notebooks, zero friction","text":"<p>\"A collection of creative AnyWidgets for Python notebook environments.\"</p>"},{"location":"#install-wigglystuff","title":"Install wigglystuff","text":"uvpip <pre><code>uv pip install wigglystuff\n</code></pre> <pre><code>pip install wigglystuff\n</code></pre>"},{"location":"#what-you-can-build","title":"What you can build","text":"Slider2D DemoAPI Matrix DemoAPI Paint DemoAPI EdgeDraw DemoAPI SortableList DemoAPI ColorPicker DemoAPI GamepadWidget DemoAPI KeystrokeWidget DemoAPI SpeechToText DemoAPI CopyToClipboard DemoAPI CellTour DemoAPI <p>Each widget page embeds a marimo-powered html-wasm export and links back to the exact notebook that generated the demo, so you can open the original <code>.py</code> file and rerun it locally.</p>"},{"location":"reference/","title":"API Overview","text":"<p>Browse widget-specific reference pages below. Each page is generated automatically via mkdocstrings, so docstrings and trait metadata from the source stay in sync with every release.</p> <ul> <li>Slider2D</li> <li>Matrix</li> <li>SortableList</li> <li>Paint</li> <li>EdgeDraw</li> <li>KeystrokeWidget</li> <li>WebkitSpeechToTextWidget</li> <li>ColorPicker</li> <li>CopyToClipboard</li> <li>Tangle widgets</li> <li>GamepadWidget</li> <li>CellTour</li> </ul>"},{"location":"reference/cell-tour/","title":"CellTour API","text":"<p>               Bases: <code>DriverTour</code></p> <p>Simplified tour widget for marimo notebooks.</p> <p>Wraps <code>DriverTour</code> with cell-aware step helpers so you can reference marimo cells by index or <code>data-cell-name</code> attributes.</p> <p>Examples:</p> <p>Using cell indices:</p> <pre><code>tour = CellTour(steps=[\n    {\"cell\": 0, \"title\": \"Imports\", \"description\": \"Load libraries\"},\n    {\"cell\": 2, \"title\": \"Processing\", \"description\": \"Data transformation\"},\n])\ntour\n</code></pre> <p>Using cell names (requires naming cells in marimo):</p> <pre><code>tour = CellTour(steps=[\n    {\"cell_name\": \"imports\", \"title\": \"Imports\", \"description\": \"Load libraries\"},\n    {\"cell_name\": \"process\", \"title\": \"Processing\", \"description\": \"Transform data\"},\n])\ntour\n</code></pre> <p>Create a CellTour widget.</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>Sequence[dict]</code> <p>List of step dictionaries with cell, title, description keys.</p> <code>()</code> <code>auto_start</code> <code>bool</code> <p>Start tour automatically on render.</p> <code>False</code> <code>show_progress</code> <code>bool</code> <p>Show step progress indicator.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Forwarded to <code>DriverTour</code>.</p> <code>{}</code> Source code in <code>wigglystuff/cell_tour.py</code> <pre><code>def __init__(\n    self,\n    steps: Sequence[dict] = (),\n    *,\n    auto_start: bool = False,\n    show_progress: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a CellTour widget.\n\n    Args:\n        steps: List of step dictionaries with cell, title, description keys.\n        auto_start: Start tour automatically on render.\n        show_progress: Show step progress indicator.\n        **kwargs: Forwarded to ``DriverTour``.\n    \"\"\"\n    transformed_steps = [self._transform_step(step) for step in steps]\n    super().__init__(\n        steps=transformed_steps,\n        auto_start=auto_start,\n        show_progress=show_progress,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/color-picker/","title":"ColorPicker API","text":"<p>               Bases: <code>AnyWidget</code></p> <p>Simple color picker syncing a <code>#RRGGBB</code> hex value back to Python.</p> <p>Examples:</p> <pre><code>picker = ColorPicker(color=\"#ff5733\")\npicker\n</code></pre> <p>Create a ColorPicker widget.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>Optional[str]</code> <p>Optional starting hex color (e.g. <code>\"#ff00aa\"</code>).</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Forwarded to <code>anywidget.AnyWidget</code>.</p> <code>{}</code> Source code in <code>wigglystuff/color_picker.py</code> <pre><code>def __init__(self, *, color: Optional[str] = None, **kwargs: Any):\n    \"\"\"Create a ColorPicker widget.\n\n    Args:\n        color: Optional starting hex color (e.g. ``\"#ff00aa\"``).\n        **kwargs: Forwarded to ``anywidget.AnyWidget``.\n    \"\"\"\n    if color is not None:\n        kwargs[\"color\"] = color\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/copy-to-clipboard/","title":"CopyToClipboard API","text":"<p>               Bases: <code>AnyWidget</code></p> <p>Button widget that copies the provided <code>text_to_copy</code> payload.</p> <p>Examples:</p> <pre><code>button = CopyToClipboard(text_to_copy=\"Hello, world!\")\nbutton\n</code></pre> <p>Create a CopyToClipboard button.</p> <p>Parameters:</p> Name Type Description Default <code>text_to_copy</code> <code>str</code> <p>Initial string placed on the clipboard when clicked.</p> <code>''</code> <code>**kwargs</code> <code>Any</code> <p>Forwarded to <code>anywidget.AnyWidget</code>.</p> <code>{}</code> Source code in <code>wigglystuff/copy_to_clipboard.py</code> <pre><code>def __init__(self, text_to_copy: str = \"\", **kwargs: Any):\n    \"\"\"Create a CopyToClipboard button.\n\n    Args:\n        text_to_copy: Initial string placed on the clipboard when clicked.\n        **kwargs: Forwarded to ``anywidget.AnyWidget``.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.text_to_copy = text_to_copy\n</code></pre>"},{"location":"reference/edge-draw/","title":"EdgeDraw API","text":"<p>               Bases: <code>AnyWidget</code></p> <p>Sketch node/link diagrams and sync edges as adjacency-friendly data.</p> <p>Examples:</p> <pre><code>graph = EdgeDraw(names=[\"A\", \"B\", \"C\", \"D\"])\ngraph\n</code></pre> <p>Create an EdgeDraw widget.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>List[str]</code> <p>Ordered list of node labels.</p> required <code>height</code> <code>int</code> <p>Canvas height in pixels.</p> <code>400</code> <code>width</code> <code>int</code> <p>Canvas width in pixels.</p> <code>600</code> Source code in <code>wigglystuff/edge_draw.py</code> <pre><code>def __init__(self, names: List[str], height: int = 400, width: int = 600) -&gt; None:\n    \"\"\"Create an EdgeDraw widget.\n\n    Args:\n        names: Ordered list of node labels.\n        height: Canvas height in pixels.\n        width: Canvas width in pixels.\n    \"\"\"\n    super().__init__(names=names, height=height, width=width)\n</code></pre>"},{"location":"reference/edge-draw/#wigglystuff.edge_draw.EdgeDraw.get_adjacency_matrix","title":"get_adjacency_matrix","text":"<pre><code>get_adjacency_matrix(directed: bool = False) -&gt; ndarray\n</code></pre> <p>Create an adjacency matrix from links and node names.</p> Source code in <code>wigglystuff/edge_draw.py</code> <pre><code>def get_adjacency_matrix(self, directed: bool = False) -&gt; np.ndarray:\n    \"\"\"Create an adjacency matrix from links and node names.\"\"\"\n    num_nodes = len(self.names)\n    matrix = np.zeros((num_nodes, num_nodes))\n    for nodes in self.links:\n        src = self.names.index(nodes[\"source\"])\n        dst = self.names.index(nodes[\"target\"])\n        matrix[src][dst] = 1\n        if not directed:\n            matrix[dst][src] = 1\n    return matrix\n</code></pre>"},{"location":"reference/edge-draw/#wigglystuff.edge_draw.EdgeDraw.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(\n    node_name: str, directed: bool = False\n) -&gt; List[str]\n</code></pre> <p>Return neighbors of a node.</p> Source code in <code>wigglystuff/edge_draw.py</code> <pre><code>def get_neighbors(self, node_name: str, directed: bool = False) -&gt; List[str]:\n    \"\"\"Return neighbors of a node.\"\"\"\n    neighbors = []\n    for nodes in self.links:\n        if nodes[\"source\"] == node_name:\n            neighbors.append(nodes[\"target\"])\n        if not directed and nodes[\"target\"] == node_name:\n            neighbors.append(nodes[\"source\"])\n    return neighbors\n</code></pre>"},{"location":"reference/edge-draw/#wigglystuff.edge_draw.EdgeDraw.has_cycle","title":"has_cycle","text":"<pre><code>has_cycle(directed: bool = False) -&gt; bool\n</code></pre> <p>Check if the graph contains cycles.</p> Source code in <code>wigglystuff/edge_draw.py</code> <pre><code>def has_cycle(self, directed: bool = False) -&gt; bool:\n    \"\"\"Check if the graph contains cycles.\"\"\"\n    if directed:\n        return self._has_cycle_directed()\n    return self._has_cycle_undirected()\n</code></pre>"},{"location":"reference/gamepad/","title":"GamepadWidget API","text":"<p>               Bases: <code>AnyWidget</code></p> <p>Listen to browser gamepad events and sync state back to Python.</p> <p>This widget does not require any initialization arguments; all state is mirrored through traitlets such as <code>axes</code> and <code>current_button_press</code>.</p> <p>Examples:</p> <pre><code>gamepad = GamepadWidget()\ngamepad\n</code></pre>"},{"location":"reference/keystroke/","title":"KeystrokeWidget API","text":"<p>               Bases: <code>AnyWidget</code></p> <p>Capture the latest keyboard shortcut pressed inside the widget.</p> <p>No initialization arguments are required; the widget simply records keystrokes into the <code>last_key</code> trait.</p> <p>Examples:</p> <pre><code>keystroke = KeystrokeWidget()\nkeystroke\n</code></pre>"},{"location":"reference/matrix/","title":"Matrix API","text":"<p>               Bases: <code>AnyWidget</code></p> <p>Spreadsheet-like numeric editor with bounds, naming, and symmetry helpers.</p> <p>Examples:</p> <pre><code>matrix = Matrix(rows=3, cols=3, min_value=0, max_value=10)\nmatrix\n</code></pre> <p>Create a Matrix editor.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Optional[List[List[float]]]</code> <p>Optional 2D list of initial values.</p> <code>None</code> <code>rows</code> <code>int</code> <p>Number of rows when <code>matrix</code> is omitted.</p> <code>3</code> <code>cols</code> <code>int</code> <p>Number of columns when <code>matrix</code> is omitted.</p> <code>3</code> <code>min_value</code> <code>float</code> <p>Lower bound for cell values.</p> <code>-100</code> <code>max_value</code> <code>float</code> <p>Upper bound for cell values.</p> <code>100</code> <code>triangular</code> <code>bool</code> <p>If <code>True</code>, enforce triangular editing constraints.</p> <code>False</code> <code>row_names</code> <code>Optional[List[str]]</code> <p>Custom labels for rows.</p> <code>None</code> <code>col_names</code> <code>Optional[List[str]]</code> <p>Custom labels for columns.</p> <code>None</code> <code>static</code> <code>bool</code> <p>Disable editing when <code>True</code>.</p> <code>False</code> <code>flexible_cols</code> <code>bool</code> <p>Allow column count changes interactively.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Forwarded to <code>anywidget.AnyWidget</code>.</p> <code>{}</code> Source code in <code>wigglystuff/matrix.py</code> <pre><code>def __init__(\n    self,\n    matrix: Optional[List[List[float]]] = None,\n    rows: int = 3,\n    cols: int = 3,\n    min_value: float = -100,\n    max_value: float = 100,\n    triangular: bool = False,\n    row_names: Optional[List[str]] = None,\n    col_names: Optional[List[str]] = None,\n    static: bool = False,\n    flexible_cols: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a Matrix editor.\n\n    Args:\n        matrix: Optional 2D list of initial values.\n        rows: Number of rows when ``matrix`` is omitted.\n        cols: Number of columns when ``matrix`` is omitted.\n        min_value: Lower bound for cell values.\n        max_value: Upper bound for cell values.\n        triangular: If ``True``, enforce triangular editing constraints.\n        row_names: Custom labels for rows.\n        col_names: Custom labels for columns.\n        static: Disable editing when ``True``.\n        flexible_cols: Allow column count changes interactively.\n        **kwargs: Forwarded to ``anywidget.AnyWidget``.\n    \"\"\"\n    if matrix is not None:\n        matrix_array = np.array(matrix)\n        if matrix_array.min() &lt; min_value:\n            raise ValueError(\n                f\"The min value of input matrix is less than min_value={min_value}.\"\n            )\n        if matrix_array.max() &gt; max_value:\n            raise ValueError(\n                f\"The max value of input matrix is less than max_value={max_value}.\"\n            )\n        rows, cols = matrix_array.shape\n        matrix = matrix_array.tolist()\n    else:\n        matrix = [\n            [(min_value + max_value) / 2 for _ in range(cols)]\n            for _ in range(rows)\n        ]\n\n    if row_names is not None and len(row_names) != rows:\n        raise ValueError(\n            f\"Length of row_names ({len(row_names)}) must match number of rows ({rows}).\"\n        )\n    if col_names is not None and len(col_names) != cols:\n        raise ValueError(\n            f\"Length of col_names ({len(col_names)}) must match number of columns ({cols}).\"\n        )\n\n    if row_names is None:\n        row_names = []\n    if col_names is None:\n        col_names = []\n\n    super().__init__(\n        matrix=matrix,\n        rows=rows,\n        cols=cols,\n        min_value=min_value,\n        max_value=max_value,\n        triangular=triangular,\n        row_names=row_names,\n        col_names=col_names,\n        static=static,\n        flexible_cols=flexible_cols,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/paint/","title":"Paint API","text":"<p>               Bases: <code>AnyWidget</code></p> <p>Notebook-friendly paint widget with MS Paint style tools and PIL helpers.</p> <p>Examples:</p> <pre><code>paint = Paint(width=400, height=300)\npaint\n</code></pre> <p>Create a Paint widget.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>Canvas height in pixels.</p> <code>DEFAULT_HEIGHT</code> <code>width</code> <code>int</code> <p>Canvas width in pixels (ignored when <code>init_image</code> sets aspect ratio).</p> <code>DEFAULT_WIDTH</code> <code>store_background</code> <code>bool</code> <p>Persist previous strokes when background changes.</p> <code>True</code> <code>init_image</code> <code>Optional[Any]</code> <p>Optional path/URL/PIL image/bytes to preload.</p> <code>None</code> Source code in <code>wigglystuff/paint.py</code> <pre><code>def __init__(self, height: int = DEFAULT_HEIGHT, width: int = DEFAULT_WIDTH, store_background: bool = True, init_image: Optional[Any] = None):\n    \"\"\"Create a Paint widget.\n\n    Args:\n        height: Canvas height in pixels.\n        width: Canvas width in pixels (ignored when ``init_image`` sets aspect ratio).\n        store_background: Persist previous strokes when background changes.\n        init_image: Optional path/URL/PIL image/bytes to preload.\n    \"\"\"\n    super().__init__()\n\n    user_provided_width = width != DEFAULT_WIDTH\n    user_provided_height = height != DEFAULT_HEIGHT\n\n    if init_image is not None and user_provided_width:\n        raise ValueError(\n            \"Cannot specify both init_image and explicit width parameter. \"\n            \"Canvas width is automatically calculated from the image aspect ratio.\"\n        )\n\n    if init_image is not None:\n        pil_image = input_to_pil(init_image)\n        if pil_image is not None:\n            image_width, image_height = pil_image.size\n            aspect_ratio = image_width / image_height\n\n            if user_provided_height:\n                self.height = height\n                self.width = int(height * aspect_ratio)\n            else:\n                self.width = image_width\n                self.height = image_height\n\n            encoded = pil_to_base64(pil_image).split(\",\")[1]\n            self.base64 = encoded\n        else:\n            self.width = width\n            self.height = height\n            self.base64 = \"\"\n    else:\n        self.width = width\n        self.height = height\n        self.base64 = \"\"\n\n    self.store_background = store_background\n</code></pre>"},{"location":"reference/paint/#wigglystuff.paint.Paint.get_base64","title":"get_base64","text":"<pre><code>get_base64() -&gt; str\n</code></pre> <p>Return the current drawing as a base64 string (data URL).</p> Source code in <code>wigglystuff/paint.py</code> <pre><code>def get_base64(self) -&gt; str:\n    \"\"\"Return the current drawing as a base64 string (data URL).\"\"\"\n    if not self.base64:\n        return \"\"\n    return pil_to_base64(self.get_pil())\n</code></pre>"},{"location":"reference/paint/#wigglystuff.paint.Paint.get_pil","title":"get_pil","text":"<pre><code>get_pil()\n</code></pre> <p>Return the current drawing as a PIL Image.</p> Source code in <code>wigglystuff/paint.py</code> <pre><code>def get_pil(self):\n    \"\"\"Return the current drawing as a PIL Image.\"\"\"\n    if not self.base64:\n        return create_empty_image(width=self.width, height=self.height, background_color=(0, 0, 0, 0))\n\n    return base64_to_pil(self.base64)\n</code></pre>"},{"location":"reference/slider2d/","title":"Slider2D API","text":"<p>               Bases: <code>AnyWidget</code></p> <p>Two dimensional slider for simultaneous adjustments.</p> <p>Emits synchronized <code>x</code>/<code>y</code> floats that stay within configurable bounds while rendering to a pixel canvas sized via <code>width</code>/<code>height</code>.</p> <p>Examples:</p> <pre><code>slider = Slider2D(x=0.5, y=0.5, x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0))\nslider\n</code></pre> <p>Create a Slider2D widget.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Initial x coordinate.</p> <code>0.0</code> <code>y</code> <code>float</code> <p>Initial y coordinate.</p> <code>0.0</code> <code>width</code> <code>int</code> <p>Canvas width in pixels.</p> <code>400</code> <code>height</code> <code>int</code> <p>Canvas height in pixels.</p> <code>400</code> <code>x_bounds</code> <code>tuple[float, float]</code> <p>Min/max tuple for x.</p> <code>(-1.0, 1.0)</code> <code>y_bounds</code> <code>tuple[float, float]</code> <p>Min/max tuple for y.</p> <code>(-1.0, 1.0)</code> <code>**kwargs</code> <code>Any</code> <p>Forwarded to <code>anywidget.AnyWidget</code>.</p> <code>{}</code> Source code in <code>wigglystuff/slider2d.py</code> <pre><code>def __init__(\n    self,\n    x: float = 0.0,\n    y: float = 0.0,\n    width: int = 400,\n    height: int = 400,\n    x_bounds: tuple[float, float] = (-1.0, 1.0),\n    y_bounds: tuple[float, float] = (-1.0, 1.0),\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a Slider2D widget.\n\n    Args:\n        x: Initial x coordinate.\n        y: Initial y coordinate.\n        width: Canvas width in pixels.\n        height: Canvas height in pixels.\n        x_bounds: Min/max tuple for x.\n        y_bounds: Min/max tuple for y.\n        **kwargs: Forwarded to ``anywidget.AnyWidget``.\n    \"\"\"\n    super().__init__(\n        x=x,\n        y=y,\n        width=width,\n        height=height,\n        x_bounds=x_bounds,\n        y_bounds=y_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/sortable-list/","title":"SortableList API","text":"<p>               Bases: <code>AnyWidget</code></p> <p>Drag-and-drop list widget with optional add/remove/edit affordances.</p> <p>Examples:</p> <pre><code>sortable = SortableList(value=[\"apple\", \"banana\", \"cherry\"], removable=True)\nsortable\n</code></pre> <p>Create a sortable list widget.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Sequence[str]</code> <p>Initial sequence of string items.</p> required <code>addable</code> <code>bool</code> <p>Allow inserting new entries.</p> <code>False</code> <code>removable</code> <code>bool</code> <p>Allow deleting entries.</p> <code>False</code> <code>editable</code> <code>bool</code> <p>Enable inline text editing.</p> <code>False</code> <code>label</code> <code>str</code> <p>Optional heading shown above the list.</p> <code>''</code> <code>**kwargs</code> <code>Any</code> <p>Forwarded to <code>anywidget.AnyWidget</code>.</p> <code>{}</code> Source code in <code>wigglystuff/sortable_list.py</code> <pre><code>def __init__(\n    self,\n    value: Sequence[str],\n    *,\n    addable: bool = False,\n    removable: bool = False,\n    editable: bool = False,\n    label: str = \"\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a sortable list widget.\n\n    Args:\n        value: Initial sequence of string items.\n        addable: Allow inserting new entries.\n        removable: Allow deleting entries.\n        editable: Enable inline text editing.\n        label: Optional heading shown above the list.\n        **kwargs: Forwarded to ``anywidget.AnyWidget``.\n    \"\"\"\n    super().__init__(\n        value=list(value),\n        addable=addable,\n        removable=removable,\n        editable=editable,\n        label=label,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/talk/","title":"WebkitSpeechToTextWidget API","text":"<p>               Bases: <code>AnyWidget</code></p> <p>Speech-to-text widget backed by the browser's Webkit Speech API.</p> <p>The widget exposes the <code>transcript</code> text along with the <code>listening</code> and <code>trigger_listen</code> booleans; it does not require initialization arguments.</p> <p>Examples:</p> <pre><code>speech = WebkitSpeechToTextWidget()\nspeech\n</code></pre>"},{"location":"reference/tangle/","title":"Tangle Widgets API","text":"<p>               Bases: <code>AnyWidget</code></p> <p>Inline slider inspired by Bret Victor's Tangle UI.</p> <p>Examples:</p> <pre><code>slider = TangleSlider(amount=50, min_value=0, max_value=100)\nslider\n</code></pre> <p>Create a slider suitable for inline Tangle interactions.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>Optional[float]</code> <p>Starting value; defaults to midpoint of bounds.</p> <code>None</code> <code>min_value</code> <code>float</code> <p>Lower bound.</p> <code>-100</code> <code>max_value</code> <code>float</code> <p>Upper bound.</p> <code>100</code> <code>step</code> <code>float</code> <p>Increment size.</p> <code>1.0</code> <code>pixels_per_step</code> <code>int</code> <p>Drag distance per step.</p> <code>2</code> <code>prefix</code> <code>str</code> <p>Text shown before the value.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>Text shown after the value.</p> <code>''</code> <code>digits</code> <code>int</code> <p>Number formatting precision.</p> <code>1</code> <code>**kwargs</code> <code>Any</code> <p>Forwarded to <code>anywidget.AnyWidget</code>.</p> <code>{}</code> Source code in <code>wigglystuff/tangle.py</code> <pre><code>def __init__(\n    self,\n    amount: Optional[float] = None,\n    min_value: float = -100,\n    max_value: float = 100,\n    step: float = 1.0,\n    pixels_per_step: int = 2,\n    prefix: str = \"\",\n    suffix: str = \"\",\n    digits: int = 1,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Create a slider suitable for inline Tangle interactions.\n\n    Args:\n        amount: Starting value; defaults to midpoint of bounds.\n        min_value: Lower bound.\n        max_value: Upper bound.\n        step: Increment size.\n        pixels_per_step: Drag distance per step.\n        prefix: Text shown before the value.\n        suffix: Text shown after the value.\n        digits: Number formatting precision.\n        **kwargs: Forwarded to ``anywidget.AnyWidget``.\n    \"\"\"\n    if amount is None:\n        amount = (max_value + min_value) / 2\n    super().__init__(\n        amount=amount,\n        min_value=min_value,\n        max_value=max_value,\n        step=step,\n        pixels_per_step=pixels_per_step,\n        prefix=prefix,\n        suffix=suffix,\n        digits=digits,\n        **kwargs,\n    )\n</code></pre> <p>               Bases: <code>AnyWidget</code></p> <p>Inline choice widget that cycles through labeled options.</p> <p>Examples:</p> <pre><code>choice = TangleChoice(choices=[\"small\", \"medium\", \"large\"])\nchoice\n</code></pre> <p>Create a TangleChoice widget.</p> <p>Parameters:</p> Name Type Description Default <code>choices</code> <code>List[str]</code> <p>Ordered sequence of options (min two).</p> required <code>**kwargs</code> <code>Any</code> <p>Forwarded to <code>anywidget.AnyWidget</code>.</p> <code>{}</code> Source code in <code>wigglystuff/tangle.py</code> <pre><code>def __init__(self, choices: List[str], **kwargs: Any) -&gt; None:\n    \"\"\"Create a TangleChoice widget.\n\n    Args:\n        choices: Ordered sequence of options (min two).\n        **kwargs: Forwarded to ``anywidget.AnyWidget``.\n    \"\"\"\n    if len(choices) &lt; 2:\n        raise ValueError(\"Must pass at least two choices.\")\n    super().__init__(value=choices[1], choices=choices, **kwargs)\n</code></pre> <p>               Bases: <code>AnyWidget</code></p> <p>Dropdown-based take on the Tangle choice pattern.</p> <p>Examples:</p> <pre><code>select = TangleSelect(choices=[\"red\", \"green\", \"blue\"])\nselect\n</code></pre> <p>Create a TangleSelect dropdown.</p> <p>Parameters:</p> Name Type Description Default <code>choices</code> <code>List[str]</code> <p>Ordered sequence of options (min two).</p> required <code>**kwargs</code> <code>Any</code> <p>Forwarded to <code>anywidget.AnyWidget</code>.</p> <code>{}</code> Source code in <code>wigglystuff/tangle.py</code> <pre><code>def __init__(self, choices: List[str], **kwargs: Any) -&gt; None:\n    \"\"\"Create a TangleSelect dropdown.\n\n    Args:\n        choices: Ordered sequence of options (min two).\n        **kwargs: Forwarded to ``anywidget.AnyWidget``.\n    \"\"\"\n    if len(choices) &lt; 2:\n        raise ValueError(\"Must pass at least two choices.\")\n    super().__init__(choice=choices[0], choices=choices, **kwargs)\n</code></pre>"}]}